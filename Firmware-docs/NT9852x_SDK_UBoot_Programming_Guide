U-Boot

Of course. Let's break this down. This document is a **programming guide** for a very specific piece of software called **U-Boot** on a Novatek NT98520 chip.

Think of it like this:
*   **The NT98520 Chip:** This is the "brain" of a device, like a high-resolution security camera or a advanced car dashboard system. It's a System-on-a-Chip (SoC).
*   **Linux SDK:** This is the "toolkit" (Software Development Kit) used to create the software that runs on this brain. It includes the Linux operating system, drivers, and other tools.
*   **U-Boot:** This is the **"bootloader."** It's the *very first* program that runs when you turn the device on. Its job is to wake up the hardware, prepare it, and then load and start the main operating system (Linux). It's like the computer's BIOS, but much more powerful and customizable.

This guide explains how to configure, build, and use this special U-Boot for the NT98520.

---

### Step-by-Step Explanation of the PDF

Hereâ€™s a walkthrough of what each section means, with simple analogies and examples.

#### **1. Features (Page 4)**
This is a summary of what this U-Boot version can do.
*   **Multi-core boot:** The NT98520 has multiple processor cores. U-Boot knows how to initialize all of them correctly.
*   **Boot from different places:** It can load the main OS from various storage types: NAND flash, NOR flash, SD card, or even directly from a network (Ethernet). This is useful for different product designs (cheaper vs. faster storage) and for developers testing new software.
*   **Update with "all-in-one" images:** Novatek provides a tool to pack all software pieces (U-Boot, Linux, the root filesystem) into a single file (`FW98520A.bin` for updating flash, `FW98520T.bin` for running from RAM). U-Boot can process these files.
*   **Checksum:** It can verify the integrity of the software images to ensure they weren't corrupted during download or storage.

> **Example:** Imagine you're building a car. The "features" are that the car can start with a key, a push-button, or even a remote app (different boot sources). It can also receive a complete software update file from the manufacturer and install it itself (all-in-one update).

#### **2. Environment Setup & Compiling (Page 5)**
This is the "how to build it" section.
*   **Setup:** It tells you to go read another manual (`SDK Pure Linux Programming Guide.pdf`) to install all the necessary tools on your computer (like a compiler, linker, etc.). This is like getting your workshop ready with all the right tools.
*   **Compilation:** It gives you the commands to turn the human-readable source code into a binary file the chip can understand.
    *   `make uboot` = "Build the U-Boot program."
    *   `make uboot_clean` = "Clean up the workshop, delete all the previous build files."
    *   It produces a compressed (`u-boot.lz.bin`) and a normal (`u-boot.bin`) version.

#### **3. System Configuration (Pages 6-13)**
This is the most important part for customization. It's where you **tell U-Boot exactly what kind of hardware it's running on.**

*   **3.1 Functionality Setting:** You edit configuration files to match your hardware.
    *   **Flash Type:** You tell it what storage chip is on your board (e.g., `ENBMEM = "ENBMEM_SPI_NAND";`).
    *   **Memory Map:** You define the addresses in RAM where U-Boot will put different parts of the operating system during boot. This is like assigning specific rooms in a house for specific activities (e.g., "the Linux kernel will stay in this room at address `0x0x01000000`").
    *   **Root Filesystem Type:** You specify the format of the main OS storage (e.g., `SQUASHFS` for a read-only system, `UBIFS` for a writable NAND flash system). This changes the boot commands.
    *   **Environment Variables:** You set where U-Boot should save its settings (e.g., in a special section of the flash memory). This is crucial for the `saveenv` command to work.

*   **3.2 User Modification: Disable Checksum:** For advanced users, it shows how to remove the checksum feature if they don't want the security check during boot.

> **Example:** You're building two camera models: a cheap one with slow storage (NAND) and a premium one with fast storage (eMMC). You would create two different configuration files. For the cheap model, you'd set `ENBMEM = "ENBMEM_SPI_NAND"` and `NVT_ROOTFS_TYPE = "NVT_ROOTFS_TYPE_NAND_UBI"`. For the premium model, you'd set `ENBMEM = "ENBMEM_EMMC"` and `NVT_ROOTFS_TYPE = "NVT_ROOTFS_TYPE_EMMC"`.

#### **4. Update Flow (Pages 15-19)**
This explains the different ways to get new software onto the device.

*   **4.1 Update from SD Card:** Using Novatek's Windows tool (NvtPack) to create an `FW98520A.bin` file, put it on an SD card, and boot the device to automatically install it.
*   **4.2 Update from Ethernet (TFTP):** Very useful for developers.
    *   `eth_init` -> Initialize the network chip.
    *   `tftp 0x01800000 FW98520A.bin` -> **Download** the update file from a TFTP server on your network into the device's RAM at address `0x01800000`.
    *   `nvt_update_all 0x1800000 0` -> **Install** the file from RAM onto the flash storage.
*   **4.3 Update by U-Boot Shell (Manual):** For experts who want to update individual parts.
    *   Commands like `nand erase`, `nand write`, `sf probe`, `sf write` are used to manually erase and write specific sections of the flash memory with new data.

#### **5. Add New Flash Support (Pages 20-21)**
The world has many brands of flash memory chips. If your board uses a new chip that isn't listed in U-Boot's internal database, you have to add it. This section shows you which files to modify to add the new chip's ID and its properties (size, page size, etc.).

#### **6. Add USB Support (Page 22)**
Shows how to enable USB functionality in U-Boot, which can be used for tasks like exposing the storage as a USB drive to a PC (`UMS` command).

#### **7. NVT Defined Commands (Page 23)**
Lists custom commands Novatek added to U-Boot.
*   `nvt_boot` -> The main command that starts the boot process.
*   `nvt_update_all` -> The command used to process the all-in-one update file.

#### **8. Boot Flow (Pages 24-25)**
Describes the process of booting Linux over the network (**Ethernet boot**), which is a huge time-saver during development. Instead of burning the software to flash over and over, you can load it directly into RAM and run it.
1.  Interrupt the automatic boot.
2.  `eth_init` and `ping` to set up the network.
3.  `tftp 0x2000 Fw98520A.ext.bin` -> Load a hardware configuration file.
4.  `tftp 0x01800000 Fw98520A.bin` -> Load the Linux kernel.
5.  Boot it.

#### **9. Burn Image to Flash (Pages 26-27)**
Provides the exact command sequences for manually writing images to the three types of storage (NOR, NAND, eMMC). This is the detailed "how-to" for the commands mentioned in section 4.3.

#### **10. Customization (Pages 28-29)**
A helpful summary pointing you to the key source code files (`nvt_fw_update.c`, `na51055_utils.c`) if you need to deeply customize the update or boot processes yourself.

---

### **In-Depth Use Case Example: Bringing Up a New Device**

Let's imagine you are an engineer designing a new smart doorbell with the NT98520.

1.  **Prototype Hardware:** You get the first prototype board from the factory. It has a **SPI NAND flash** chip (brand: XYZ, model: ABC123) and an Ethernet port.

2.  **Configuration:** You open the file `nvt-na51055-info.dtsi` and set:
    *   `ENBMEM = "ENBMEM_SPI_NAND";`
    *   `NVT_ROOTFS_TYPE = "NVT_ROOTFS_TYPE_NAND_UBI";` // You want a writable filesystem for logs.
    *   `NVT_UBOOT_ENV_IN_STORG_SUPPORT = "NVT_UBOOT_ENV_IN_STORG_SUPPORT_NAND";` // Save settings on the NAND.

3.  **Add New Flash:** You look up the datasheet for the "XYZ ABC123" NAND chip. You find its manufacturer ID is `0xAB` and device ID is `0xCD`. You add a new entry to `nand_ids.c`:
    ```c
    SPI_ID_NAND("XYZ ABC123", 0xAB, 0xCD, 2048, 256, 0x20000, NAND_NO_SUBPAGE_WRITE),
    ```

4.  **Build:** You run `make uboot_clean` and then `make uboot`. It generates your custom `u-boot.bin`.

5.  **First Boot (via SD Card):** You use the **NvtPack** tool on your Windows PC to create an all-in-one `FW98520A.bin` file that contains your new U-Boot, a Linux kernel, and a test filesystem. You put this file on an SD card, plug it into the doorbell, and power it on. The factory bootloader detects the SD card and automatically flashes your new software.

6.  **Development & Debugging:** The doorbell now boots your software. Now, you need to test new Linux kernel versions every day. **Burning flash is slow.** So, you use **Ethernet boot**:
    *   You set up a TFTP server on your PC with the new `uImage` (Linux kernel) file.
    *   You connect the doorbell to your network and open a serial console to its U-Boot.
    *   You type:
        ```
        uboot> eth_init
        uboot> setenv serverip 192.168.1.50  # Your PC's IP
        uboot> setenv ipaddr 192.168.1.100   # The doorbell's IP
        uboot> tftp 0x01800000 uImage        # Load kernel into RAM
        uboot> nvt_boot                      # Boot it!
        ```
    The new kernel loads from the network in seconds, and you can test it immediately. If it crashes, you just reboot and try again without damaging the flash.

7.  **Final Production:** Once the software is perfect, you create a final `FW98520A.bin` and use the `nvt_update_all` command one last time to permanently burn it to the doorbell's flash memory. It's now ready to be shipped to customers.

This document is the essential roadmap that guides you through all these steps for the NT98520 platform.
