Of course. This document is a user guide for setting up and working with a specific type of filesystem (UBI/UBIFS) on a Novatek NT9852x chip, which is commonly used in embedded systems like cameras, IoT devices, etc.

Since you have no prior knowledge, let's break this down from the very beginning, step-by-step.

### 1. The Big Picture: What Problem Are We Solving?

Imagine you have a small computer (the NT9852x chip) that doesn't have a hard drive. Instead, it uses a **flash memory chip** (like a very robust SD card) to store its operating system (Linux) and applications.

There are two main types of flash memory:
*   **NOR Flash:** Reliable, but expensive and small. Like a read-only book.
*   **NAND Flash:** Cheaper and has more space, but has a quirk: **it develops "bad blocks" over time**. Parts of the memory wear out and can no longer reliably store data. It's like a notebook where some pages might become unreadable.

This guide teaches you how to use a filesystem called **UBIFS** on this NAND flash. UBIFS is smart enough to work around these bad blocks, ensuring your device doesn't crash when parts of its memory fail.

---

### 2. Key Concepts Explained Simply

Before we dive into the steps, let's understand the key players:

*   **MTD (Memory Technology Device):** This is the Linux subsystem that provides a generic interface to access raw flash memory chips (both NOR and NAND). Think of it as the **"raw flash driver."** `/dev/mtd0`, `/dev/mtd1` etc., are MTD devices.
*   **UBI (Unsorted Block Images):** This is a **volume management system** that sits on top of MTD. Its main jobs are:
    1.  **Wear Leveling:** It spreads out data writes evenly across the entire flash chip to prevent any single block from wearing out too quickly.
    2.  **Bad Block Handling:** It transparently maps out bad blocks and replaces them with good ones from a reserved pool.
*   **UBIFS (UBI File System):** This is the actual **filesystem** (like NTFS on Windows or ext4 on Linux) that sits on top of a UBI volume. You store your files and directories here. It supports compression to save space.
*   **Squashfs:** A highly compressed, **read-only** filesystem. It's often used for the main system files that don't need to change. The guide shows how to put a Squashfs image inside a UBI volume to get both compression *and* bad block handling.

The relationship looks like this:
`UBIFS (Files & Folders)` -> `UBI Volume` -> `UBI (Manager)` -> `MTD (Raw Flash)` -> `Physical NAND Chip`

---

### 3. Step-by-Step Walkthrough of the PDF

Now, let's go through the document page by page, translating it into actionable steps.

#### **Page 3: Introduction & Linux Kernel Settings**
*   **What it says:** UBIFS is the default filesystem. It's fast, handles power failures well, and supports compression (LZO or Zlib).
*   **What you need to do:** You must enable these options in the Linux kernel's configuration menu (`make menuconfig`):
    *   `Device Drivers -> Memory Technology Device (MTD) support -> Enable UBI`
    *   `File systems -> Miscellaneous filesystems -> UBIFS file system support` and `LZO compression support`.

#### **Page 4: Telling the System to Use UBI for Rootfs**
*   **What it says:** The "rootfs" is the root filesystem, the main drive that contains the OS. You need to configure the device tree to specify that rootfs should be of type `NVT_ROOTFS_TYPE_NAND_UBI`.
*   **What you need to do:** Edit the file `configs/cfg_xxx/nvt-na51055-info.dtsi` and set the `NVT_ROOTFS_TYPE` variable correctly.
*   **Example:**
    ```c
    nvt_info {
        ...
        NVT_ROOTFS_TYPE = "NVT_ROOTFS_TYPE_NAND_UBI"; // This is the key line
        ...
    };
    ```

#### **Pages 5-7: Automatic Build Configuration (The Heart of the Guide)**
This is the most important part. You need to tell the build system exactly how your flash memory is organized.

*   **What it says:** You must define parameters like page size, block size, and overall size so the tools can build a working UBIFS image.
*   **What you need to do:** Edit the file `na51055_linux_sdk/BSP/root-fs/mtd_cfg.txt`.
*   **Example with a typical flash chip:**
    Let's say your NAND flash has:
    *   Page Size: **2048 bytes** (2KiB)
    *   Pages per Block: **64**
    *   Block Size: **64 pages * 2048 bytes = 131072 bytes (128KiB)**
    *   Total Size: **128MiB** (1024 blocks)

    You would set the following in `mtd_cfg.txt`:

    ```bash
    # The sub-page size is often the same as the page size
    ROOTFS_UBI_SUB_PAGE_SIZE=2048
    # The page size of your flash
    ROOTFS_UBI_PAGE_SIZE=2048
    # (Pages per Block - 2) * Page Size. (64 - 2) * 2048 = 126976
    ROOTFS_UBI_ERASE_BLK_SIZE=126976
    # The compression algorithm
    ROOTFS_UBI_COMPRESS_MODE="lzo"
    # The block size of your flash, in KiB
    ROOTFS_UBI_BLK_SIZE="128KiB"

    # Now, calculate the LEB Count. Logical Erase Blocks are how UBI sees the flash.
    # If your rootfs partition is 0x2500000 bytes (~37 MiB), you run:
    # $ cd BSP/root-fs/
    # $ python ubi_max_leb.py 0x2500000
    # It will output a number, e.g., 260. You then put that number here.
    ROOTFS_UBI_MAX_LEB_COUNT=260
    ROOTFS_UBI_RW_MAX_LEB_COUNT=258
    ```
    **Crucial Note:** The value `30` in the script `ubi_max_leb.py` (for bad block calculation) **must match** the value set in the kernel menuconfig (`Maximum expected bad eraseblock count`). If you change one, change the other!

#### **Pages 8-9: Manually Building Images**
The PDF shows you how to build the images yourself without the automated system, which is great for learning.

**Step 1: Create a UBIFS Image**
This packages a folder (e.g., `rootfs.tmp`) into a `.ubifs` image file.
```bash
# -m 2048   (Page Size)
# -e 126976 (Erase Block Size from calculation)
# -c 260    (LEB Count from calculation)
# -o        (Output file)
# -r        (Root directory of the files)
mkfs.ubifs --squash-uids -x "lzo" -m 2048 -e 126976 -c 260 -o bin/rootfs.ubifs.img -r rootfs.tmp
```

**Step 2 & 3: Create a UBI Image**
The `.ubifs` image needs to be wrapped into a `.ubi` image that includes UBI volume information.
1.  Create a config file `ubinize.cfg`:
    ```ini
    [ubifs]
    mode=ubi
    image=bin/rootfs.ubifs.img # Path to the file from step 1
    vol_id=0
    vol_size=33013760          # LEB Count * Erase Block Size: 260 * 126976
    vol_type=dynamic
    vol_name=rootfs            # The name you will use to mount it
    ```
2.  Run `ubinize` to create the final image:
    ```bash
    # -m 2048      (Page Size)
    # -p "128KiB"  (Physical Block Size)
    # -s 2048      (Sub-Page Size)
    # -o           (Output file)
    ubinize -m 2048 -p "128KiB" -s 2048 -o bin/rootfs.ubi.img ubinize.cfg
    ```
The `rootfs.ubi.img` is now ready to be written directly to the flash memory.

#### **Pages 10-11: Squashfs on UBI**
This is a common setup: a read-only, compressed Squashfs for the system files, inside a UBI volume for bad block protection.
1.  **Kernel Config:** Enable `Read-only block devices on top of UBI volumes`.
2.  **Bootargs:** Tell the kernel to boot from the UBI block device: `ubi.block=0,0 root=/dev/ubiblock0_0 rootfstype=squashfs`
3.  **Build:** First create a Squashfs image (`mksquashfs`), then use `ubinize` (as in Step 3 above) to put that Squashfs image into a UBI volume.

#### **Pages 12-16: Frequently Asked Questions (FAQ)**
*   **7.1: Changing Flash Chips:** If you use a different flash chip (e.g., with 4KiB pages instead of 2KiB), you must update **EVERY** parameter: hardware bootstrap setting, device tree addresses and sizes, `ubi_max_leb.py` variables (`W`, `SP`, `SL`), and all values in `mtd_cfg.txt`.
*   **7.3: Updating in a Running Linux System:** This is very useful for developers. It shows how to format a flash partition and deploy a new image from the command line of a running device.
    *   **To update a `ubifs` image:**
        ```bash
        # Attach MTD partition 6 to UBI, creating /dev/ubi0
        ubiattach -p /dev/mtd6
        # Create a volume on that UBI device called "rootfs"
        ubimkvol /dev/ubi0 -N rootfs -s 40MiB
        # Write your new image to the volume
        ubiupdatevol /dev/ubi0_0 /path/to/new_image.ubifs.bin
        ```
    *   **To update a `ubi` image:**
        ```bash
        # Erase the entire MTD partition
        flash_eraseall /dev/mtd6
        # Write the raw UBI image to the MTD partition
        nandwrite /dev/mtd6 /path/to/new_image.ubi.img
        # Now attach it so the system can use it
        ubiattach -p /dev/mtd6
        ```

### Summary and How to Get Started Now

1.  **Identify Your Flash Chip:** Find its datasheet. You need **Page Size**, **Block Size** (Pages per Block * Page Size), and **Total Size**.
2.  **Configure the Kernel:** Use `make menuconfig` to enable UBI and UBIFS support.
3.  **Edit the Device Tree:** Set `NVT_ROOTFS_TYPE = "NVT_ROOTFS_TYPE_NAND_UBI";` in the `nvt-na51055-info.dtsi` file.
4.  **Configure the Build:** This is the crucial step. Calculate your `ERASE_BLK_SIZE` and `LEB_COUNT` and put all the correct values into `BSP/root-fs/mtd_cfg.txt`.
5.  **Build:** Run the build command (e.g., `make all`). The SDK will automatically run `mkfs.ubifs` and `ubinize` for you using the parameters you provided, creating a final `*.ubi.img` file.
6.  **Flash:** Write the generated `*.ubi.img` file to the correct partition of your device's flash memory using a programming tool or the `nandwrite` command in U-Boot or Linux.

This process ensures your device has a robust filesystem that can handle the imperfections of NAND flash memory.
